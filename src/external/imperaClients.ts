/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.3.0 (NJsonSchema v9.10.46.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AccountClient {
    private http: {
        fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        baseUrl?: string,
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        }
    ) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:57676";
    }

    exchange(
        loginRequest: LoginRequest | null | undefined
    ): Promise<LoginResponseModel | null> {
        let url_ = this.baseUrl + "/api/Account/token";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (loginRequest !== null && loginRequest !== undefined)
            content_.append("loginRequest", loginRequest.toString());

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExchange(_response);
        });
    }

    protected processExchange(
        response: Response
    ): Promise<LoginResponseModel | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <LoginResponseModel>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<LoginResponseModel | null>(<any>null);
    }

    /**
     * Checks if a username is available
     * @userName Username to check
     * @return True if username is available
     */
    getUserNameAvailable(userName: string | null): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/UserNameAvailable?";
        if (userName === undefined)
            throw new Error("The parameter 'userName' must be defined.");
        else url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserNameAvailable(_response);
        });
    }

    protected processGetUserNameAvailable(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Get user information
     */
    getUserInfo(): Promise<UserInfo | null> {
        let url_ = this.baseUrl + "/api/Account/UserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetUserInfo(_response);
        });
    }

    protected processGetUserInfo(response: Response): Promise<UserInfo | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <UserInfo>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<UserInfo | null>(<any>null);
    }

    /**
     * Get user information for an external user (i.e., just logged in using an external provider)
     */
    getExternalUserInfo(): Promise<UserInfo | null> {
        let url_ = this.baseUrl + "/api/Account/ExternalUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalUserInfo(_response);
        });
    }

    protected processGetExternalUserInfo(
        response: Response
    ): Promise<UserInfo | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <UserInfo>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<UserInfo | null>(<any>null);
    }

    logout(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    getManageInfo(
        returnUrl: string | null,
        generateState: boolean | undefined
    ): Promise<ManageInfoViewModel | null> {
        let url_ = this.baseUrl + "/api/Account/ManageInfo?";
        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&";
        if (generateState === null)
            throw new Error("The parameter 'generateState' cannot be null.");
        else if (generateState !== undefined)
            url_ +=
                "generateState=" + encodeURIComponent("" + generateState) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetManageInfo(_response);
        });
    }

    protected processGetManageInfo(
        response: Response
    ): Promise<ManageInfoViewModel | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <ManageInfoViewModel>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<ManageInfoViewModel | null>(<any>null);
    }

    changePassword(
        model: ChangePasswordBindingModel | null
    ): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    setPassword(
        model: SetPasswordBindingModel | null
    ): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/SetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetPassword(_response);
        });
    }

    protected processSetPassword(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    deleteAccount(model: DeleteAccountBindingModel | null): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/Delete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteAccount(_response);
        });
    }

    protected processDeleteAccount(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                return;
            });
        } else if (status === 400) {
            return response.text().then(_responseText => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : <ErrorResponse>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return throwException(
                    "A server error occurred.",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    setLanguage(language: string | null): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/Language?";
        if (language === undefined)
            throw new Error("The parameter 'language' must be defined.");
        else url_ += "language=" + encodeURIComponent("" + language) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSetLanguage(_response);
        });
    }

    protected processSetLanguage(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    removeLogin(
        model: RemoveLoginBindingModel | null
    ): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/RemoveLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveLogin(_response);
        });
    }

    protected processRemoveLogin(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    getExternalLogins(): Promise<ExternalLoginViewModel[] | null> {
        let url_ = this.baseUrl + "/api/Account/ExternalLogins";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetExternalLogins(_response);
        });
    }

    protected processGetExternalLogins(
        response: Response
    ): Promise<ExternalLoginViewModel[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <ExternalLoginViewModel[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<ExternalLoginViewModel[] | null>(<any>null);
    }

    register(model: RegisterBindingModel | null): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                return;
            });
        } else if (status === 400) {
            return response.text().then(_responseText => {
                let result400: any = null;
                result400 =
                    _responseText === ""
                        ? null
                        : <ErrorResponse>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return throwException(
                    "A server error occurred.",
                    status,
                    _responseText,
                    _headers,
                    result400
                );
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Resend the email confirmation account to the given user account
     */
    resendConfirmationCode(
        model: ResendConfirmationModel | null
    ): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/ResendConfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResendConfirmationCode(_response);
        });
    }

    protected processResendConfirmationCode(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Confirm user account using code provided in mail
     * @model Model containing id and code
     * @return Success if successfully activated
     */
    confirmEmail(
        model: ConfirmationModel | null
    ): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/ConfirmEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processConfirmEmail(_response);
        });
    }

    protected processConfirmEmail(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Request password reset link
     */
    forgotPassword(
        model: ForgotPasswordViewModel | null
    ): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Reset password confirmation
     */
    resetPassword(
        model: ResetPasswordViewModel | null
    ): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Create user accout for an external login
     */
    registerExternal(
        model: RegisterExternalBindingModel | null
    ): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/Account/RegisterExternal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRegisterExternal(_response);
        });
    }

    protected processRegisterExternal(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class AllianceClient {
    private http: {
        fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        baseUrl?: string,
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        }
    ) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:57676";
    }

    /**
     * Get a list of all alliances
     * @return Alliance summaries
     */
    getAll(): Promise<AllianceSummary[] | null> {
        let url_ = this.baseUrl + "/api/alliances";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(
        response: Response
    ): Promise<AllianceSummary[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <AllianceSummary[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<AllianceSummary[] | null>(<any>null);
    }

    /**
     * Create a new alliance
     * @creationOptions Creation options
     * @return Summary of new alliance
     */
    create(
        creationOptions: AllianceCreationOptions | null
    ): Promise<AllianceSummary | null> {
        let url_ = this.baseUrl + "/api/alliances";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(creationOptions);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(
        response: Response
    ): Promise<AllianceSummary | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <AllianceSummary>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<AllianceSummary | null>(<any>null);
    }

    /**
     * Lists all requests to join an alliance by the current user
     * @return List of requests
     */
    getAllRequests(): Promise<AllianceJoinRequest[] | null> {
        let url_ = this.baseUrl + "/api/alliances/requests";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllRequests(_response);
        });
    }

    protected processGetAllRequests(
        response: Response
    ): Promise<AllianceJoinRequest[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <AllianceJoinRequest[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<AllianceJoinRequest[] | null>(<any>null);
    }

    /**
     * Get detailed information about a single alliance
     * @allianceId Id of the requested alliance
     * @return Information about the requested alliance
     */
    get(allianceId: string): Promise<Alliance | null> {
        let url_ = this.baseUrl + "/api/alliances/{allianceId}";
        if (allianceId === undefined || allianceId === null)
            throw new Error("The parameter 'allianceId' must be defined.");
        url_ = url_.replace(
            "{allianceId}",
            encodeURIComponent("" + allianceId)
        );
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Alliance | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <Alliance>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Alliance | null>(<any>null);
    }

    /**
     * Delete alliance
     * @allianceId Id of alliance
     * @return Summary of new alliance
     */
    delete(allianceId: string): Promise<void> {
        let url_ = this.baseUrl + "/api/alliances/{allianceId}";
        if (allianceId === undefined || allianceId === null)
            throw new Error("The parameter 'allianceId' must be defined.");
        url_ = url_.replace(
            "{allianceId}",
            encodeURIComponent("" + allianceId)
        );
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Remove member from alliance
     * @allianceId Id of alliance
     * @userId Id of user to remove
     * @return Summary of new alliance
     */
    removeMember(allianceId: string, userId: string): Promise<void> {
        let url_ =
            this.baseUrl + "/api/alliances/{allianceId}/members/{userId}";
        if (allianceId === undefined || allianceId === null)
            throw new Error("The parameter 'allianceId' must be defined.");
        url_ = url_.replace(
            "{allianceId}",
            encodeURIComponent("" + allianceId)
        );
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRemoveMember(_response);
        });
    }

    protected processRemoveMember(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Change member's admin status
     * @allianceId Id of alliance
     * @userId Id of user to make admin
     * @return Summary of new alliance
     */
    changeAdmin(
        allianceId: string,
        userId: string,
        isAdmin: boolean
    ): Promise<void> {
        let url_ =
            this.baseUrl + "/api/alliances/{allianceId}/members/{userId}";
        if (allianceId === undefined || allianceId === null)
            throw new Error("The parameter 'allianceId' must be defined.");
        url_ = url_.replace(
            "{allianceId}",
            encodeURIComponent("" + allianceId)
        );
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(isAdmin);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processChangeAdmin(_response);
        });
    }

    protected processChangeAdmin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    /**
     * Request to join an alliance
     * @allianceId Id of the requested alliance
     * @reason Reason why user wants to join the alliance
     * @return Id of join request if created
     */
    requestJoin(
        allianceId: string,
        reason: string | null
    ): Promise<AllianceJoinRequest | null> {
        let url_ = this.baseUrl + "/api/alliances/{allianceId}/requests";
        if (allianceId === undefined || allianceId === null)
            throw new Error("The parameter 'allianceId' must be defined.");
        url_ = url_.replace(
            "{allianceId}",
            encodeURIComponent("" + allianceId)
        );
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reason);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processRequestJoin(_response);
        });
    }

    protected processRequestJoin(
        response: Response
    ): Promise<AllianceJoinRequest | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <AllianceJoinRequest>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<AllianceJoinRequest | null>(<any>null);
    }

    /**
     * Lists requests to join an alliance
     * @allianceId Id of the alliance
     * @return List of requests
     */
    getRequests(allianceId: string): Promise<AllianceJoinRequest[] | null> {
        let url_ = this.baseUrl + "/api/alliances/{allianceId}/requests";
        if (allianceId === undefined || allianceId === null)
            throw new Error("The parameter 'allianceId' must be defined.");
        url_ = url_.replace(
            "{allianceId}",
            encodeURIComponent("" + allianceId)
        );
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetRequests(_response);
        });
    }

    protected processGetRequests(
        response: Response
    ): Promise<AllianceJoinRequest[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <AllianceJoinRequest[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<AllianceJoinRequest[] | null>(<any>null);
    }

    /**
     * Updates a request to join an alliance. Requests can only be updated when they are in a pending state
     * @allianceId Id of the requested alliance
     * @requestId Id of the request to change
     * @state New request state
     */
    updateRequest(
        allianceId: string,
        requestId: string,
        state: AllianceJoinRequestState
    ): Promise<AllianceJoinRequest | null> {
        let url_ =
            this.baseUrl + "/api/alliances/{allianceId}/requests/{requestId}";
        if (allianceId === undefined || allianceId === null)
            throw new Error("The parameter 'allianceId' must be defined.");
        url_ = url_.replace(
            "{allianceId}",
            encodeURIComponent("" + allianceId)
        );
        if (requestId === undefined || requestId === null)
            throw new Error("The parameter 'requestId' must be defined.");
        url_ = url_.replace("{requestId}", encodeURIComponent("" + requestId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(state);

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdateRequest(_response);
        });
    }

    protected processUpdateRequest(
        response: Response
    ): Promise<AllianceJoinRequest | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <AllianceJoinRequest>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<AllianceJoinRequest | null>(<any>null);
    }
}

export class GameClient {
    private http: {
        fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        baseUrl?: string,
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        }
    ) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:57676";
    }

    /**
     * Get a list of open games, excluding games by the current player
     * @return List of games
     */
    getAll(): Promise<GameSummary[] | null> {
        let url_ = this.baseUrl + "/api/games/open";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<GameSummary[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <GameSummary[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<GameSummary[] | null>(<any>null);
    }

    /**
     * Get a list of the games for the current player
     * @return List of games for the current user
     */
    getMy(): Promise<GameSummary[] | null> {
        let url_ = this.baseUrl + "/api/games/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMy(_response);
        });
    }

    protected processGetMy(response: Response): Promise<GameSummary[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <GameSummary[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<GameSummary[] | null>(<any>null);
    }

    /**
     * Get list of games where it's the current player's team
     * @return List of games where it's the current user's team
     */
    getMyTurn(): Promise<GameSummary[] | null> {
        let url_ = this.baseUrl + "/api/games/myturn";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMyTurn(_response);
        });
    }

    protected processGetMyTurn(
        response: Response
    ): Promise<GameSummary[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <GameSummary[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<GameSummary[] | null>(<any>null);
    }

    /**
     * Create a new game
     * @creationOptions Creation options
     * @return Summary of newly created game
     */
    post(
        creationOptions: GameCreationOptions | null
    ): Promise<GameSummary | null> {
        let url_ = this.baseUrl + "/api/games";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(creationOptions);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<GameSummary | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <GameSummary>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<GameSummary | null>(<any>null);
    }

    /**
     * Get detailed information about a single game
     * @gameId Id of the requested game
     * @return Information about the requested game
     */
    get(gameId: number): Promise<Game | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Game | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <Game>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Game | null>(<any>null);
    }

    /**
     * Cancel/delete the requested game, if possible.
     * @gameId Id of the game to delete
     * @return Status
     */
    delete(gameId: number): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Get messages for a single game
     * @gameId Id of the requested game
     * @isPublic (optional) Value indicating whether to return only public messages, default is true
     * @return Messages posted in the requested game
     */
    getMessages(
        gameId: number,
        isPublic: boolean | undefined
    ): Promise<GameChatMessage[] | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/messages?";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        if (isPublic === null)
            throw new Error("The parameter 'isPublic' cannot be null.");
        else if (isPublic !== undefined)
            url_ += "isPublic=" + encodeURIComponent("" + isPublic) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMessages(_response);
        });
    }

    protected processGetMessages(
        response: Response
    ): Promise<GameChatMessage[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <GameChatMessage[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<GameChatMessage[] | null>(<any>null);
    }

    /**
     * Join the given game
     * @gameId Id of game to join
     * @password Optional password
     */
    postJoin(
        gameId: number,
        password: string | null
    ): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/join?";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        if (password === undefined)
            throw new Error("The parameter 'password' must be defined.");
        else url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostJoin(_response);
        });
    }

    protected processPostJoin(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Leave the given game, only possible if game hasn't started yet, and current player
    is not the creator.
     * @gameId Id of game to leave
     */
    postLeave(gameId: number): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/leave";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostLeave(_response);
        });
    }

    protected processPostLeave(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Surrender in the given game, only possible if current player
    and game are still active.
     * @gameId Id of game to surrender in
     */
    postSurrender(gameId: number): Promise<GameSummary | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/surrender";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostSurrender(_response);
        });
    }

    protected processPostSurrender(
        response: Response
    ): Promise<GameSummary | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <GameSummary>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<GameSummary | null>(<any>null);
    }

    /**
     * Hides the given game for the current player
     * @gameId Id of game to hide
     */
    patchHide(gameId: number): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/hide";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPatchHide(_response);
        });
    }

    protected processPatchHide(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Hide all games which can be hidden for the current player
     */
    patchHideAll(): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/games/hide";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPatchHideAll(_response);
        });
    }

    protected processPatchHideAll(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class HistoryClient {
    private http: {
        fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        baseUrl?: string,
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        }
    ) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:57676";
    }

    /**
     * Gets the specified turn including the actions and current state of the map
     */
    getTurn(gameId: number, turnId: number): Promise<HistoryTurn | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/history/{turnId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        if (turnId === undefined || turnId === null)
            throw new Error("The parameter 'turnId' must be defined.");
        url_ = url_.replace("{turnId}", encodeURIComponent("" + turnId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTurn(_response);
        });
    }

    protected processGetTurn(response: Response): Promise<HistoryTurn | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <HistoryTurn>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<HistoryTurn | null>(<any>null);
    }
}

export class LadderClient {
    private http: {
        fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        baseUrl?: string,
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        }
    ) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:57676";
    }

    /**
     * Returns active ladders
     * @return List of ladders
     */
    getAll(): Promise<LadderSummary[] | null> {
        let url_ = this.baseUrl + "/api/ladder";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(
        response: Response
    ): Promise<LadderSummary[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <LadderSummary[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<LadderSummary[] | null>(<any>null);
    }

    /**
     * Gets ladder identified by given id
     * @ladderId Id of ladder
     */
    get(ladderId: string): Promise<Ladder | null> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}";
        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Ladder | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <Ladder>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Ladder | null>(<any>null);
    }

    /**
     * Queue up for a new game in the given ladder
     * @ladderId Ladder id
     */
    postJoin(ladderId: string): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}/queue";
        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostJoin(_response);
        });
    }

    protected processPostJoin(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Leave the queue for a ladder
     * @ladderId Ladder Id
     */
    deleteJoin(ladderId: string): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}/queue";
        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteJoin(_response);
        });
    }

    protected processDeleteJoin(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class MapClient {
    private http: {
        fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        baseUrl?: string,
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        }
    ) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:57676";
    }

    getAllSummary(): Promise<MapTemplateDescriptor[] | null> {
        let url_ = this.baseUrl + "/api/map";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAllSummary(_response);
        });
    }

    protected processGetAllSummary(
        response: Response
    ): Promise<MapTemplateDescriptor[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <MapTemplateDescriptor[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<MapTemplateDescriptor[] | null>(<any>null);
    }

    /**
     * Get map template identified by name
     */
    getMapTemplate(name: string): Promise<MapTemplate | null> {
        let url_ = this.baseUrl + "/api/map/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetMapTemplate(_response);
        });
    }

    protected processGetMapTemplate(
        response: Response
    ): Promise<MapTemplate | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <MapTemplate>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<MapTemplate | null>(<any>null);
    }
}

export class MessageClient {
    private http: {
        fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        baseUrl?: string,
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        }
    ) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:57676";
    }

    getAll(messageFolder: MessageFolder): Promise<Message[] | null> {
        let url_ = this.baseUrl + "/api/messages/folder/{messageFolder}";
        if (messageFolder === undefined || messageFolder === null)
            throw new Error("The parameter 'messageFolder' must be defined.");
        url_ = url_.replace(
            "{messageFolder}",
            encodeURIComponent("" + messageFolder)
        );
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<Message[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <Message[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Message[] | null>(<any>null);
    }

    get(messageId: string): Promise<Message | null> {
        let url_ = this.baseUrl + "/api/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<Message | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <Message>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Message | null>(<any>null);
    }

    patchMarkRead(messageId: string): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "PATCH",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPatchMarkRead(_response);
        });
    }

    protected processPatchMarkRead(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    delete(messageId: string): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    getFolderInformation(): Promise<FolderInformation[] | null> {
        let url_ = this.baseUrl + "/api/messages/folders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetFolderInformation(_response);
        });
    }

    protected processGetFolderInformation(
        response: Response
    ): Promise<FolderInformation[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <FolderInformation[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FolderInformation[] | null>(<any>null);
    }

    postSend(message: SendMessage | null): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/messages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostSend(_response);
        });
    }

    protected processPostSend(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class NewsClient {
    private http: {
        fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        baseUrl?: string,
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        }
    ) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:57676";
    }

    /**
     * Returns the last 10 news items for all languages
     * @return List of news items
     */
    getAll(): Promise<NewsItem[] | null> {
        let url_ = this.baseUrl + "/api/news";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<NewsItem[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <NewsItem[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<NewsItem[] | null>(<any>null);
    }
}

export class NotificationClient {
    private http: {
        fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        baseUrl?: string,
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        }
    ) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:57676";
    }

    /**
     * Get notification summary for current user
     */
    getSummary(): Promise<NotificationSummary | null> {
        let url_ = this.baseUrl + "/api/notifications/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetSummary(_response);
        });
    }

    protected processGetSummary(
        response: Response
    ): Promise<NotificationSummary | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <NotificationSummary>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<NotificationSummary | null>(<any>null);
    }
}

export class PlayClient {
    private http: {
        fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        baseUrl?: string,
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        }
    ) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:57676";
    }

    /**
     * Place units to countries.
     * @gameId Id of the game
     * @placeUnitsOptions List of country/unit count pairs
     * @return GameActionResult of action
     */
    postPlace(
        gameId: number,
        placeUnitsOptions: PlaceUnitsOptions[] | null
    ): Promise<GameActionResult | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/place";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(placeUnitsOptions);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostPlace(_response);
        });
    }

    protected processPostPlace(
        response: Response
    ): Promise<GameActionResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <GameActionResult>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<GameActionResult | null>(<any>null);
    }

    /**
     * Exchange cards for the current player. Which cards to exchange is automatically chosen to gain the most bonus for the player.
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postExchange(gameId: number): Promise<GameActionResult | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/exchange";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostExchange(_response);
        });
    }

    protected processPostExchange(
        response: Response
    ): Promise<GameActionResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <GameActionResult>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<GameActionResult | null>(<any>null);
    }

    /**
     * Attack from one to another country.
     * @gameId Id of the game
     * @options Options for the command
     * @return GameActionResult of action
     */
    postAttack(
        gameId: number,
        options: AttackOptions | null
    ): Promise<GameActionResult | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/attack";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostAttack(_response);
        });
    }

    protected processPostAttack(
        response: Response
    ): Promise<GameActionResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <GameActionResult>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<GameActionResult | null>(<any>null);
    }

    /**
     * Switch to moving.
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postEndAttack(gameId: number): Promise<GameActionResult | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/endattack";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostEndAttack(_response);
        });
    }

    protected processPostEndAttack(
        response: Response
    ): Promise<GameActionResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <GameActionResult>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<GameActionResult | null>(<any>null);
    }

    /**
     * Move units between countries. Only allowed after placing. Cancels any attacks that the player had left before. Attacking is not
    possible anymore after moving.
     * @gameId Id of the game
     * @options Options for the command
     * @return GameActionResult of action
     */
    postMove(
        gameId: number,
        options: MoveOptions | null
    ): Promise<GameActionResult | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/move";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostMove(_response);
        });
    }

    protected processPostMove(
        response: Response
    ): Promise<GameActionResult | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <GameActionResult>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<GameActionResult | null>(<any>null);
    }

    /**
     * End the current turn
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postEndTurn(gameId: number): Promise<Game | null> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/endturn";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostEndTurn(_response);
        });
    }

    protected processPostEndTurn(response: Response): Promise<Game | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <Game>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Game | null>(<any>null);
    }
}

export class TournamentClient {
    private http: {
        fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        baseUrl?: string,
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        }
    ) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:57676";
    }

    /**
     * Returns tournaments
     * @return List of tournaments
     */
    getAll(): Promise<TournamentSummary[] | null> {
        let url_ = this.baseUrl + "/api/tournaments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(
        response: Response
    ): Promise<TournamentSummary[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <TournamentSummary[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<TournamentSummary[] | null>(<any>null);
    }

    /**
     * Get tournament identified by Id
     * @tournamentId Id of tournament
     */
    getById(tournamentId: string): Promise<Tournament | null> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace(
            "{tournamentId}",
            encodeURIComponent("" + tournamentId)
        );
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: Response): Promise<Tournament | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <Tournament>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<Tournament | null>(<any>null);
    }

    /**
     * Join tournament
     * @tournamentId Id of tournament
     */
    postJoin(tournamentId: string): Promise<TournamentTeam | null> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace(
            "{tournamentId}",
            encodeURIComponent("" + tournamentId)
        );
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostJoin(_response);
        });
    }

    protected processPostJoin(
        response: Response
    ): Promise<TournamentTeam | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <TournamentTeam>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<TournamentTeam | null>(<any>null);
    }

    /**
     * Get teams for tournament
     * @tournamentId Id of tournament
     */
    getTeams(tournamentId: string): Promise<TournamentTeam[] | null> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace(
            "{tournamentId}",
            encodeURIComponent("" + tournamentId)
        );
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetTeams(_response);
        });
    }

    protected processGetTeams(
        response: Response
    ): Promise<TournamentTeam[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <TournamentTeam[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<TournamentTeam[] | null>(<any>null);
    }

    /**
     * Create new team for a tournament
     * @tournamentId Id of tournament
     * @name Name of team
     * @password (optional) Optional password for team
     * @return Summary of newly created team
     */
    postCreateTeam(
        tournamentId: string,
        name: string | null,
        password: string | null | undefined
    ): Promise<TournamentTeam | null> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams?";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace(
            "{tournamentId}",
            encodeURIComponent("" + tournamentId)
        );
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostCreateTeam(_response);
        });
    }

    protected processPostCreateTeam(
        response: Response
    ): Promise<TournamentTeam | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <TournamentTeam>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<TournamentTeam | null>(<any>null);
    }

    /**
     * Get teams for tournament pairing
     * @pairingId Id of tournament pairing
     */
    getGamesForPairing(pairingId: string): Promise<GameSummary[] | null> {
        let url_ = this.baseUrl + "/api/tournaments/pairings/{pairingId}";
        if (pairingId === undefined || pairingId === null)
            throw new Error("The parameter 'pairingId' must be defined.");
        url_ = url_.replace("{pairingId}", encodeURIComponent("" + pairingId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetGamesForPairing(_response);
        });
    }

    protected processGetGamesForPairing(
        response: Response
    ): Promise<GameSummary[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <GameSummary[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<GameSummary[] | null>(<any>null);
    }

    /**
     * Join existing team
     * @tournamentId Id of tournament
     * @teamId Id of team
     * @password (optional) Optional password for team to join
     */
    postJoinTeam(
        tournamentId: string,
        teamId: string,
        password: string | null | undefined
    ): Promise<TournamentTeam | null> {
        let url_ =
            this.baseUrl + "/api/tournaments/{tournamentId}/teams/{teamId}?";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace(
            "{tournamentId}",
            encodeURIComponent("" + tournamentId)
        );
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPostJoinTeam(_response);
        });
    }

    protected processPostJoinTeam(
        response: Response
    ): Promise<TournamentTeam | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <TournamentTeam>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<TournamentTeam | null>(<any>null);
    }

    /**
     * Delete a team. Only allowed if user created it
     * @tournamentId Id of tournament
     * @teamId Id of team to delete
     */
    deleteTeam(
        tournamentId: string,
        teamId: string
    ): Promise<FileResponse | null> {
        let url_ =
            this.baseUrl + "/api/tournaments/{tournamentId}/teams/{teamId}";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace(
            "{tournamentId}",
            encodeURIComponent("" + tournamentId)
        );
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDeleteTeam(_response);
        });
    }

    protected processDeleteTeam(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }

    /**
     * Leave a team and tournament
     * @tournamentId Id of tournament
     */
    leaveTournament(tournamentId: string): Promise<FileResponse | null> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/me";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace(
            "{tournamentId}",
            encodeURIComponent("" + tournamentId)
        );
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLeaveTournament(_response);
        });
    }

    protected processLeaveTournament(
        response: Response
    ): Promise<FileResponse | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers
                ? response.headers.get("content-disposition")
                : undefined;
            const fileNameMatch = contentDisposition
                ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
                : undefined;
            const fileName =
                fileNameMatch && fileNameMatch.length > 1
                    ? fileNameMatch[1]
                    : undefined;
            return response.blob().then(blob => {
                return {
                    fileName: fileName,
                    data: blob,
                    status: status,
                    headers: _headers
                };
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<FileResponse | null>(<any>null);
    }
}

export class UserClient {
    private http: {
        fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
    };
    private baseUrl: string;
    protected jsonParseReviver:
        | ((key: string, value: any) => any)
        | undefined = undefined;

    constructor(
        baseUrl?: string,
        http?: {
            fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;
        }
    ) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:57676";
    }

    /**
     * Find users starting with the given query
     * @query Query to search for
     */
    findUsers(query: string): Promise<UserReference[] | null> {
        let url_ = this.baseUrl + "/api/users/find/{query}";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url_ = url_.replace("{query}", encodeURIComponent("" + query));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json",
                Accept: "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processFindUsers(_response);
        });
    }

    protected processFindUsers(
        response: Response
    ): Promise<UserReference[] | null> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && response.headers.forEach) {
            response.headers.forEach((v: any, k: any) => (_headers[k] = v));
        }
        if (status === 200) {
            return response.text().then(_responseText => {
                let result200: any = null;
                result200 =
                    _responseText === ""
                        ? null
                        : <UserReference[]>(
                              JSON.parse(_responseText, this.jsonParseReviver)
                          );
                return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then(_responseText => {
                return throwException(
                    "An unexpected server error occurred.",
                    status,
                    _responseText,
                    _headers
                );
            });
        }
        return Promise.resolve<UserReference[] | null>(<any>null);
    }
}

export interface LoginRequest {
    grant_type?: string | undefined;
    username?: string | undefined;
    password?: string | undefined;
    scope?: string | undefined;
    refresh_token?: string | undefined;
}

export interface LoginResponseModel {
    access_token?: string | undefined;
    refresh_token?: string | undefined;
}

export interface UserInfo {
    userId?: string | undefined;
    userName?: string | undefined;
    hasRegistered: boolean;
    loginProvider?: string | undefined;
    language?: string | undefined;
    roles?: string[] | undefined;
    allianceId?: string | undefined;
    allianceAdmin: boolean;
}

export interface ManageInfoViewModel {
    localLoginProvider?: string | undefined;
    userName?: string | undefined;
    logins?: UserLoginInfoViewModel[] | undefined;
    externalLoginProviders?: ExternalLoginViewModel[] | undefined;
}

export interface UserLoginInfoViewModel {
    loginProvider?: string | undefined;
    providerKey?: string | undefined;
}

export interface ExternalLoginViewModel {
    name?: string | undefined;
    authenticationScheme?: string | undefined;
}

export interface ChangePasswordBindingModel {
    oldPassword: string;
    newPassword: string;
    confirmPassword?: string | undefined;
}

export interface SetPasswordBindingModel {
    newPassword: string;
    confirmPassword?: string | undefined;
}

export interface DeleteAccountBindingModel {
    password: string;
}

export interface ErrorResponse {
    error?: string | undefined;
    error_Description?: string | undefined;
    parameter_Errors?: { [key: string]: string[] } | undefined;
}

export interface RemoveLoginBindingModel {
    loginProvider: string;
    providerKey: string;
}

export interface RegisterBindingModel {
    userName: string;
    password: string;
    confirmPassword?: string | undefined;
    email: string;
    language: string;
    callbackUrl: string;
}

export interface ResendConfirmationModel {
    callbackUrl: string;
    userName: string;
    password: string;
    language: string;
}

export interface ConfirmationModel {
    userId: string;
    code: string;
}

export interface ForgotPasswordViewModel {
    callbackUrl: string;
    userName: string;
    email: string;
    language: string;
}

export interface ResetPasswordViewModel {
    userId: string;
    password: string;
    confirmPassword?: string | undefined;
    code: string;
}

export interface RegisterExternalBindingModel {
    userName: string;
    email: string;
}

export interface AllianceSummary {
    id: string;
    name?: string | undefined;
    description?: string | undefined;
    numberOfMembers: number;
    admins?: UserReference[] | undefined;
}

export interface UserReference {
    id?: string | undefined;
    name?: string | undefined;
}

export interface AllianceJoinRequest {
    id: string;
    createdAt: Date;
    allianceId: string;
    lastModifiedAt: Date;
    requestedByUser?: UserReference | undefined;
    state: AllianceJoinRequestState;
    reason?: string | undefined;
}

export enum AllianceJoinRequestState {
    Active = "Active",
    Approved = "Approved",
    Denied = "Denied"
}

export interface Alliance extends AllianceSummary {
    members?: UserReference[] | undefined;
}

export interface AllianceCreationOptions {
    name: string;
    description: string;
}

export interface GameSummary {
    id: number;
    type: GameType;
    name?: string | undefined;
    hasPassword: boolean;
    ladderId?: string | undefined;
    ladderName?: string | undefined;
    options?: GameOptions | undefined;
    createdByUserId?: string | undefined;
    createdByName?: string | undefined;
    startedAt?: Date | undefined;
    lastActionAt: Date;
    timeoutSecondsLeft: number;
    mapTemplate?: string | undefined;
    state: GameState;
    currentPlayer?: PlayerSummary | undefined;
    teams?: TeamSummary[] | undefined;
    turnCounter: number;
}

export enum GameType {
    Fun = "Fun",
    Ranking = "Ranking",
    Tournament = "Tournament"
}

export interface GameOptions {
    numberOfPlayersPerTeam: number;
    numberOfTeams: number;
    minUnitsPerCountry: number;
    newUnitsPerTurn: number;
    attacksPerTurn: number;
    movesPerTurn: number;
    initialCountryUnits: number;
    mapDistribution: MapDistribution;
    timeoutInSeconds: number;
    maximumTimeoutsPerPlayer: number;
    maximumNumberOfCards: number;
    victoryConditions: VictoryConditionType[];
    visibilityModifier: VisibilityModifierType[];
}

export enum MapDistribution {
    Default = "Default",
    Malibu = "Malibu"
}

export enum VictoryConditionType {
    Survival = "Survival",
    ControlContinent = "ControlContinent"
}

export enum VisibilityModifierType {
    None = "None",
    Fog = "Fog"
}

export enum GameState {
    None = "None",
    Open = "Open",
    Active = "Active",
    Ended = "Ended"
}

export interface PlayerSummary {
    id: string;
    userId?: string | undefined;
    name?: string | undefined;
    state: PlayerState;
    outcome: PlayerOutcome;
    teamId: string;
    playOrder: number;
    timeouts: number;
}

export enum PlayerState {
    None = "None",
    Active = "Active",
    InActive = "InActive"
}

export enum PlayerOutcome {
    None = "None",
    Won = "Won",
    Defeated = "Defeated",
    Surrendered = "Surrendered",
    Timeout = "Timeout"
}

export interface TeamSummary {
    id: string;
    playOrder: number;
    players?: PlayerSummary[] | undefined;
}

export interface GameCreationOptions extends GameOptions {
    name: string;
    password?: string | undefined;
    addBot: boolean;
    mapTemplate: string;
}

export interface Game {
    id: number;
    type: GameType;
    name?: string | undefined;
    hasPassword: boolean;
    mapTemplate?: string | undefined;
    teams?: Team[] | undefined;
    state: GameState;
    playState: PlayState;
    currentPlayer?: PlayerSummary | undefined;
    map?: Map | undefined;
    options?: GameOptions | undefined;
    lastModifiedAt: Date;
    timeoutSecondsLeft: number;
    turnCounter: number;
    unitsToPlace: number;
    attacksInCurrentTurn: number;
    movesInCurrentTurn: number;
}

export interface Team {
    id: string;
    playOrder: number;
    players?: Player[] | undefined;
}

export interface Player extends PlayerSummary {
    cards?: BonusCard[] | undefined;
    placedInitialUnits: boolean;
    numberOfUnits: number;
    numberOfCountries: number;
}

export enum BonusCard {
    A = "A",
    B = "B",
    C = "C"
}

export enum PlayState {
    None = "None",
    PlaceUnits = "PlaceUnits",
    Attack = "Attack",
    Move = "Move",
    Done = "Done"
}

export interface Map {
    countries?: Country[] | undefined;
}

export interface Country {
    identifier?: string | undefined;
    playerId: string;
    teamId: string;
    units: number;
}

export interface GameChatMessage {
    id: number;
    gameId: number;
    user?: UserReference | undefined;
    teamId: string;
    dateTime: Date;
    text?: string | undefined;
}

export interface HistoryTurn {
    gameId: number;
    turnId: number;
    actions?: HistoryEntry[] | undefined;
    game?: Game | undefined;
}

export interface HistoryEntry {
    id: number;
    turnNo: number;
    dateTime: Date;
    actorId: string;
    otherPlayerId?: string | undefined;
    action: HistoryAction;
    originIdentifier?: string | undefined;
    destinationIdentifier?: string | undefined;
    units?: number | undefined;
    unitsLost?: number | undefined;
    unitsLostOther?: number | undefined;
    result?: boolean | undefined;
}

export enum HistoryAction {
    None = "None",
    StartGame = "StartGame",
    EndGame = "EndGame",
    PlaceUnits = "PlaceUnits",
    Attack = "Attack",
    Move = "Move",
    ExchangeCards = "ExchangeCards",
    PlayerLost = "PlayerLost",
    PlayerWon = "PlayerWon",
    PlayerTimeout = "PlayerTimeout",
    OwnerChange = "OwnerChange",
    EndTurn = "EndTurn",
    PlayerSurrendered = "PlayerSurrendered"
}

export interface LadderSummary {
    id: string;
    name?: string | undefined;
    options?: GameOptions | undefined;
    standing?: LadderStanding | undefined;
    isQueued: boolean;
    queueCount: number;
    mapTemplates: string[];
}

export interface LadderStanding {
    userId?: string | undefined;
    userName?: string | undefined;
    position: number;
    gamesPlayed: number;
    gamesWon: number;
    gamesLost: number;
    rating: number;
    lastGame: Date;
}

export interface Ladder extends LadderSummary {
    standings?: LadderStanding[] | undefined;
    isActive: boolean;
}

export interface MapTemplateDescriptor {
    name?: string | undefined;
    isActive: boolean;
}

export interface MapTemplate {
    name?: string | undefined;
    image?: string | undefined;
    countries?: CountryTemplate[] | undefined;
    connections?: Connection[] | undefined;
    continents?: Continent[] | undefined;
}

export interface CountryTemplate {
    identifier?: string | undefined;
    name?: string | undefined;
    x: number;
    y: number;
}

export interface Connection {
    origin?: string | undefined;
    destination?: string | undefined;
}

export interface Continent {
    id: number;
    name?: string | undefined;
    bonus: number;
    countries?: string[] | undefined;
}

export enum MessageFolder {
    None = "None",
    Inbox = "Inbox",
    Sent = "Sent"
}

export interface SendMessage {
    to: UserReference;
    subject?: string | undefined;
    text?: string | undefined;
}

export interface Message extends SendMessage {
    id: string;
    from?: UserReference | undefined;
    folder: MessageFolder;
    sentAt: Date;
    isRead: boolean;
}

export interface FolderInformation {
    folder: MessageFolder;
    count: number;
    unreadCount: number;
}

export interface NewsItem {
    dateTime: Date;
    postedBy?: string | undefined;
    content?: NewsContent[] | undefined;
}

export interface NewsContent {
    language?: string | undefined;
    title?: string | undefined;
    text?: string | undefined;
}

export interface NotificationSummary {
    numberOfGames: number;
    numberOfMessages: number;
}

export interface PlaceUnitsOptions {
    countryIdentifier: string;
    numberOfUnits: number;
}

export interface GameActionResult {
    id: number;
    turnCounter: number;
    teams?: Team[] | undefined;
    state: GameState;
    playState: PlayState;
    countryUpdates?: Country[] | undefined;
    actionResult: Result;
    unitsToPlace: number;
    attacksInCurrentTurn: number;
    movesInCurrentTurn: number;
    cards?: BonusCard[] | undefined;
    currentPlayer?: Player | undefined;
}

export enum Result {
    None = "None",
    Successful = "Successful",
    NotSuccessful = "NotSuccessful"
}

export interface AttackOptions {
    originCountryIdentifier: string;
    destinationCountryIdentifier: string;
    numberOfUnits: number;
}

export interface MoveOptions {
    originCountryIdentifier: string;
    destinationCountryIdentifier: string;
    numberOfUnits: number;
}

export interface TournamentSummary {
    id: string;
    name: string;
    state: TournamentState;
    options?: GameOptions | undefined;
    numberOfTeams: number;
    numberOfGroupGames: number;
    numberOfKnockoutGames: number;
    numberOfFinalGames: number;
    startOfRegistration: Date;
    startOfTournament: Date;
    endOfTournament: Date;
    completion: number;
}

export enum TournamentState {
    Open = "Open",
    Groups = "Groups",
    Knockout = "Knockout",
    Closed = "Closed"
}

export interface Tournament extends TournamentSummary {
    teams?: TournamentTeam[] | undefined;
    groups?: TournamentGroup[] | undefined;
    pairings?: TournamentPairing[] | undefined;
    mapTemplates?: string[] | undefined;
    winner?: TournamentTeam | undefined;
    phase: number;
}

export interface TournamentTeamSummary {
    id: string;
    name?: string | undefined;
    createdById?: string | undefined;
    groupOrder: number;
    state: TournamentTeamState;
}

export interface TournamentTeam extends TournamentTeamSummary {
    participants?: UserReference[] | undefined;
}

export enum TournamentTeamState {
    Open = "Open",
    Active = "Active",
    InActive = "InActive"
}

export interface TournamentGroup {
    id: string;
    teams?: TournamentTeamSummary[] | undefined;
}

export interface TournamentPairing {
    id: string;
    teamA?: TournamentTeamSummary | undefined;
    teamB?: TournamentTeamSummary | undefined;
    teamAWon: number;
    teamBWon: number;
    numberOfGames: number;
    phase: number;
    order: number;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any };
    result: any;

    constructor(
        message: string,
        status: number,
        response: string,
        headers: { [key: string]: any },
        result: any
    ) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result?: any
): any {
    if (result !== null && result !== undefined) throw result;
    else throw new SwaggerException(message, status, response, headers, null);
}
