/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v9.12.6284.27589 (NJsonSchema v8.11.6284.26855) (http://NSwag.org)
// </auto-generated>
//----------------------


export class TournamentClient {
    private baseUrl: string | undefined = undefined;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;;
    }

    /**
     * Returns tournaments
     * @return List of tournaments
     */
    getAll(): Promise<Tournament[]> {
        let url_ = this.baseUrl + "/api/tournaments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetAll(response);
        });
    }

    protected processGetAll(response: Response): Promise<Tournament[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Tournament[] | null = null;
                result200 = responseText === "" ? null : <Tournament[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get tournament identified by Id
     * @tournamentId Id of tournament
     */
    getById(tournamentId: string): Promise<Tournament> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetById(response);
        });
    }

    protected processGetById(response: Response): Promise<Tournament> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Tournament | null = null;
                result200 = responseText === "" ? null : <Tournament>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Join tournament
     * @tournamentId Id of tournament
     */
    postJoin(tournamentId: string): Promise<TournamentTeam> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostJoin(response);
        });
    }

    protected processPostJoin(response: Response): Promise<TournamentTeam> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: TournamentTeam | null = null;
                result200 = responseText === "" ? null : <TournamentTeam>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get teams for tournament
     * @tournamentId Id of tournament
     */
    getTeams(tournamentId: string): Promise<TournamentTeam[]> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetTeams(response);
        });
    }

    protected processGetTeams(response: Response): Promise<TournamentTeam[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: TournamentTeam[] | null = null;
                result200 = responseText === "" ? null : <TournamentTeam[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Create new team for a tournament
     * @tournamentId Id of tournament
     * @name Name of team
     * @password Optional password for team
     * @return Summary of newly created team
     */
    postCreateTeam(tournamentId: string, name: string, password: string): Promise<TournamentTeamSummary> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams?";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        if (name === undefined)
            throw new Error("The parameter 'name' must be defined.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostCreateTeam(response);
        });
    }

    protected processPostCreateTeam(response: Response): Promise<TournamentTeamSummary> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: TournamentTeamSummary | null = null;
                result200 = responseText === "" ? null : <TournamentTeamSummary>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Join existing team
     * @tournamentId Id of tournament
     * @teamId Id of team
     * @password Optional password for team to join
     */
    postJoinTeam(tournamentId: string, teamId: string, password: string): Promise<any> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/{teamId}?";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostJoinTeam(response);
        });
    }

    protected processPostJoinTeam(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Delete a team. Only allowed if user created it
     * @tournamentId Id of tournament
     * @teamId Id of team to delete
     */
    deleteTeam(tournamentId: string, teamId: string): Promise<any> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/{teamId}";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        if (teamId === undefined || teamId === null)
            throw new Error("The parameter 'teamId' must be defined.");
        url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processDeleteTeam(response);
        });
    }

    protected processDeleteTeam(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Leave a team and tournament
     * @tournamentId Id of tournament
     */
    leaveTournament(tournamentId: string): Promise<any> {
        let url_ = this.baseUrl + "/api/tournaments/{tournamentId}/teams/me";
        if (tournamentId === undefined || tournamentId === null)
            throw new Error("The parameter 'tournamentId' must be defined.");
        url_ = url_.replace("{tournamentId}", encodeURIComponent("" + tournamentId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processLeaveTournament(response);
        });
    }

    protected processLeaveTournament(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, null);
    }
}

export class UserClient {
    private baseUrl: string | undefined = undefined;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;;
    }

    /**
     * Find users starting with the given query
     * @query Query to search for
     */
    findUsers(query: string): Promise<UserReference[]> {
        let url_ = this.baseUrl + "/api/users/find/{query}";
        if (query === undefined || query === null)
            throw new Error("The parameter 'query' must be defined.");
        url_ = url_.replace("{query}", encodeURIComponent("" + query)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processFindUsers(response);
        });
    }

    protected processFindUsers(response: Response): Promise<UserReference[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: UserReference[] | null = null;
                result200 = responseText === "" ? null : <UserReference[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, null);
    }
}

export class PlayClient {
    private baseUrl: string | undefined = undefined;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;;
    }

    /**
     * Place units to countries.
     * @gameId Id of the game
     * @placeUnitsOptions List of country/unit count pairs
     * @return GameActionResult of action
     */
    postPlace(gameId: number, placeUnitsOptions: PlaceUnitsOptions[]): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/place";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(placeUnitsOptions);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostPlace(response);
        });
    }

    protected processPostPlace(response: Response): Promise<GameActionResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameActionResult | null = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Exchange cards for the current player. Which cards to exchange is automatically chosen to gain the most bonus for the player.
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postExchange(gameId: number): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/exchange";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostExchange(response);
        });
    }

    protected processPostExchange(response: Response): Promise<GameActionResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameActionResult | null = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Attack from one to another country.
     * @gameId Id of the game
     * @options Options for the command
     * @return GameActionResult of action
     */
    postAttack(gameId: number, options: AttackOptions): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/attack";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostAttack(response);
        });
    }

    protected processPostAttack(response: Response): Promise<GameActionResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameActionResult | null = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Switch to moving.
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postEndAttack(gameId: number): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/endattack";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostEndAttack(response);
        });
    }

    protected processPostEndAttack(response: Response): Promise<GameActionResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameActionResult | null = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Move units between countries. Only allowed after placing. Cancels any attacks that the player had left before. Attacking is not
possible anymore after moving.
     * @gameId Id of the game
     * @options Options for the command
     * @return GameActionResult of action
     */
    postMove(gameId: number, options: MoveOptions): Promise<GameActionResult> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/move";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(options);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostMove(response);
        });
    }

    protected processPostMove(response: Response): Promise<GameActionResult> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameActionResult | null = null;
                result200 = responseText === "" ? null : <GameActionResult>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * End the current turn
     * @gameId Id of the game
     * @return GameActionResult of action
     */
    postEndTurn(gameId: number): Promise<Game> {
        let url_ = this.baseUrl + "/api/games/{gameId}/play/endturn";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostEndTurn(response);
        });
    }

    protected processPostEndTurn(response: Response): Promise<Game> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Game | null = null;
                result200 = responseText === "" ? null : <Game>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, null);
    }
}

export class NotificationClient {
    private baseUrl: string | undefined = undefined;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;;
    }

    /**
     * Get notification summary for current user
     */
    getSummary(): Promise<NotificationSummary> {
        let url_ = this.baseUrl + "/api/notifications/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetSummary(response);
        });
    }

    protected processGetSummary(response: Response): Promise<NotificationSummary> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: NotificationSummary | null = null;
                result200 = responseText === "" ? null : <NotificationSummary>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, null);
    }
}

export class NewsClient {
    private baseUrl: string | undefined = undefined;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;;
    }

    /**
     * Returns the last 10 news items for all languages
     * @return List of news items
     */
    getAll(): Promise<NewsItem[]> {
        let url_ = this.baseUrl + "/api/news";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetAll(response);
        });
    }

    protected processGetAll(response: Response): Promise<NewsItem[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: NewsItem[] | null = null;
                result200 = responseText === "" ? null : <NewsItem[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, null);
    }
}

export class MessageClient {
    private baseUrl: string | undefined = undefined;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;;
    }

    getAll(messageFolder: MessageFolder): Promise<Message[]> {
        let url_ = this.baseUrl + "/api/messages/folder?";
        if (messageFolder === null)
            throw new Error("The parameter 'messageFolder' cannot be null.");
        else if (messageFolder !== undefined)
            url_ += "messageFolder=" + encodeURIComponent("" + messageFolder) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetAll(response);
        });
    }

    protected processGetAll(response: Response): Promise<Message[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Message[] | null = null;
                result200 = responseText === "" ? null : <Message[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    get(messageId: string): Promise<Message> {
        let url_ = this.baseUrl + "/api/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGet(response);
        });
    }

    protected processGet(response: Response): Promise<Message> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Message | null = null;
                result200 = responseText === "" ? null : <Message>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    patchMarkRead(messageId: string): Promise<any> {
        let url_ = this.baseUrl + "/api/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPatchMarkRead(response);
        });
    }

    protected processPatchMarkRead(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    delete(messageId: string): Promise<any> {
        let url_ = this.baseUrl + "/api/messages/{messageId}";
        if (messageId === undefined || messageId === null)
            throw new Error("The parameter 'messageId' must be defined.");
        url_ = url_.replace("{messageId}", encodeURIComponent("" + messageId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processDelete(response);
        });
    }

    protected processDelete(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    getFolderInformation(): Promise<FolderInformation> {
        let url_ = this.baseUrl + "/api/messages/folders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetFolderInformation(response);
        });
    }

    protected processGetFolderInformation(response: Response): Promise<FolderInformation> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: FolderInformation | null = null;
                result200 = responseText === "" ? null : <FolderInformation>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    postSend(message: SendMessage): Promise<any> {
        let url_ = this.baseUrl + "/api/messages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(message);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostSend(response);
        });
    }

    protected processPostSend(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, null);
    }
}

export class AccountClient {
    private baseUrl: string | undefined = undefined;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;;
    }

    exchange(grant_type: string, username: string, password: string, scope: string, refresh_token: string): Promise<LoginResponseModel> {
        let url_ = this.baseUrl + "/api/Account/token?";
        let content_ = "";
        if (grant_type !== undefined)
            content_ += "grant_type=" + encodeURIComponent("" + grant_type) + "&"; 
        
        if (username !== undefined)
            content_ += "username=" + encodeURIComponent("" + username) + "&"; 
        
        if (password !== undefined)
            content_ += "password=" + encodeURIComponent("" + password) + "&"; 
        
        if (scope !== undefined)
            content_ += "scope=" + encodeURIComponent("" + scope) + "&"; 
        
        if (refresh_token !== undefined)        
            content_ += "refresh_token=" + encodeURIComponent("" + refresh_token) + "&";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/x-www-form-urlencoded",
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processExchange(response);
        });
    }

    protected processExchange(response: Response): Promise<LoginResponseModel> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: LoginResponseModel | null = null;
                result200 = responseText === "" ? null : <LoginResponseModel>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Checks if a username is available
     * @userName Username to check
     * @return True if username is available
     */
    getUserNameAvailable(userName: string): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/UserNameAvailable?";
        if (userName === undefined)
            throw new Error("The parameter 'userName' must be defined.");
        else
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetUserNameAvailable(response);
        });
    }

    protected processGetUserNameAvailable(response: Response): Promise<void> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                return null;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get user information
     */
    getUserInfo(): Promise<UserInfo> {
        let url_ = this.baseUrl + "/api/Account/UserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetUserInfo(response);
        });
    }

    protected processGetUserInfo(response: Response): Promise<UserInfo> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: UserInfo | null = null;
                result200 = responseText === "" ? null : <UserInfo>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get user information for an external user (i.e., just logged in using an external provider)
     */
    getExternalUserInfo(): Promise<UserInfo> {
        let url_ = this.baseUrl + "/api/Account/ExternalUserInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetExternalUserInfo(response);
        });
    }

    protected processGetExternalUserInfo(response: Response): Promise<UserInfo> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: UserInfo | null = null;
                result200 = responseText === "" ? null : <UserInfo>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    logout(): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/Logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processLogout(response);
        });
    }

    protected processLogout(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    getManageInfo(returnUrl: string, generateState: boolean): Promise<ManageInfoViewModel> {
        let url_ = this.baseUrl + "/api/Account/ManageInfo?";
        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (generateState === null)
            throw new Error("The parameter 'generateState' cannot be null.");
        else if (generateState !== undefined)
            url_ += "generateState=" + encodeURIComponent("" + generateState) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetManageInfo(response);
        });
    }

    protected processGetManageInfo(response: Response): Promise<ManageInfoViewModel> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: ManageInfoViewModel | null = null;
                result200 = responseText === "" ? null : <ManageInfoViewModel>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    changePassword(model: ChangePasswordBindingModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processChangePassword(response);
        });
    }

    protected processChangePassword(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    setPassword(model: SetPasswordBindingModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/SetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processSetPassword(response);
        });
    }

    protected processSetPassword(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    removeLogin(model: RemoveLoginBindingModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/RemoveLogin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processRemoveLogin(response);
        });
    }

    protected processRemoveLogin(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    getExternalLogins(returnUrl: string, generateState: boolean): Promise<ExternalLoginViewModel[]> {
        let url_ = this.baseUrl + "/api/Account/ExternalLogins?";
        if (returnUrl === undefined)
            throw new Error("The parameter 'returnUrl' must be defined.");
        else
            url_ += "returnUrl=" + encodeURIComponent("" + returnUrl) + "&"; 
        if (generateState === null)
            throw new Error("The parameter 'generateState' cannot be null.");
        else if (generateState !== undefined)
            url_ += "generateState=" + encodeURIComponent("" + generateState) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetExternalLogins(response);
        });
    }

    protected processGetExternalLogins(response: Response): Promise<ExternalLoginViewModel[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: ExternalLoginViewModel[] | null = null;
                result200 = responseText === "" ? null : <ExternalLoginViewModel[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    register(model: RegisterBindingModel): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processRegister(response);
        });
    }

    protected processRegister(response: Response): Promise<void> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                return null;
            } else if (status === 400) {
                let result400: ErrorResponse | null = null;
                result400 = responseText === "" ? null : <ErrorResponse>JSON.parse(responseText, this.jsonParseReviver);
                this.throwException("A server error occurred.", status, responseText, result400);
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Resend the email confirmation account to the given user account
     */
    resendConfirmationCode(model: ResendConfirmationModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/ResendConfirmation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processResendConfirmationCode(response);
        });
    }

    protected processResendConfirmationCode(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Confirm user account using code provided in mail
     * @model Model containing id and code
     * @return Success if successfully activated
     */
    confirmEmail(model: ConfirmationModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/ConfirmEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processConfirmEmail(response);
        });
    }

    protected processConfirmEmail(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Request password reset link
     */
    forgotPassword(model: ForgotPasswordViewModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/ForgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processForgotPassword(response);
        });
    }

    protected processForgotPassword(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Reset password confirmation
     */
    resetPassword(model: ResetPasswordViewModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processResetPassword(response);
        });
    }

    protected processResetPassword(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Create user accout for an external login
     */
    registerExternal(model: RegisterExternalBindingModel): Promise<any> {
        let url_ = this.baseUrl + "/api/Account/RegisterExternal";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processRegisterExternal(response);
        });
    }

    protected processRegisterExternal(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, null);
    }
}

export class GameClient {
    private baseUrl: string | undefined = undefined;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;;
    }

    /**
     * Get a list of open games, excluding games by the current player
     * @return List of games
     */
    getAll(): Promise<GameSummary[]> {
        let url_ = this.baseUrl + "/api/games/open";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetAll(response);
        });
    }

    protected processGetAll(response: Response): Promise<GameSummary[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameSummary[] | null = null;
                result200 = responseText === "" ? null : <GameSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get a list of the games for the current player
     * @return List of games for the current user
     */
    getMy(): Promise<GameSummary[]> {
        let url_ = this.baseUrl + "/api/games/my";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetMy(response);
        });
    }

    protected processGetMy(response: Response): Promise<GameSummary[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameSummary[] | null = null;
                result200 = responseText === "" ? null : <GameSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get list of games where it's the current player's team
     * @return List of games where it's the current user's team
     */
    getMyTurn(): Promise<GameSummary[]> {
        let url_ = this.baseUrl + "/api/games/myturn";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetMyTurn(response);
        });
    }

    protected processGetMyTurn(response: Response): Promise<GameSummary[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameSummary[] | null = null;
                result200 = responseText === "" ? null : <GameSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Create a new game
     * @creationOptions Creation options
     * @return Summary of newly created game
     */
    post(creationOptions: GameCreationOptions): Promise<GameSummary> {
        let url_ = this.baseUrl + "/api/games";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(creationOptions);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPost(response);
        });
    }

    protected processPost(response: Response): Promise<GameSummary> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameSummary | null = null;
                result200 = responseText === "" ? null : <GameSummary>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get detailed information about a single game
     * @gameId Id of the requested game
     * @return Information about the requested game
     */
    get(gameId: number): Promise<Game> {
        let url_ = this.baseUrl + "/api/games/{gameId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGet(response);
        });
    }

    protected processGet(response: Response): Promise<Game> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Game | null = null;
                result200 = responseText === "" ? null : <Game>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Cancel/delete the requested game, if possible.
     * @gameId Id of the game to delete
     * @return Status
     */
    delete(gameId: number): Promise<any> {
        let url_ = this.baseUrl + "/api/games/{gameId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "DELETE",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processDelete(response);
        });
    }

    protected processDelete(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get messages for a single game
     * @gameId Id of the requested game
     * @isPublic Value indicating whether to return only public messages, default is true
     * @return Messages posted in the requested game
     */
    getMessages(gameId: number, isPublic: boolean): Promise<GameChatMessage[]> {
        let url_ = this.baseUrl + "/api/games/{gameId}/messages?";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        if (isPublic === null)
            throw new Error("The parameter 'isPublic' cannot be null.");
        else if (isPublic !== undefined)
            url_ += "isPublic=" + encodeURIComponent("" + isPublic) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetMessages(response);
        });
    }

    protected processGetMessages(response: Response): Promise<GameChatMessage[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameChatMessage[] | null = null;
                result200 = responseText === "" ? null : <GameChatMessage[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Join the given game
     * @gameId Id of game to join
     */
    postJoin(gameId: number): Promise<any> {
        let url_ = this.baseUrl + "/api/games/{gameId}/join";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostJoin(response);
        });
    }

    protected processPostJoin(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Leave the given game, only possible if game hasn't started yet, and current player
is not the creator.
     * @gameId Id of game to leave
     */
    postLeave(gameId: number): Promise<any> {
        let url_ = this.baseUrl + "/api/games/{gameId}/leave";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostLeave(response);
        });
    }

    protected processPostLeave(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Surrender in the given game, only possible if current player
and game are still active.
     * @gameId Id of game to surrender in
     */
    postSurrender(gameId: number): Promise<GameSummary> {
        let url_ = this.baseUrl + "/api/games/{gameId}/surrender";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostSurrender(response);
        });
    }

    protected processPostSurrender(response: Response): Promise<GameSummary> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: GameSummary | null = null;
                result200 = responseText === "" ? null : <GameSummary>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Hides the given game for the current player
     * @gameId Id of game to hide
     */
    patchHide(gameId: number): Promise<any> {
        let url_ = this.baseUrl + "/api/games/{gameId}/hide";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPatchHide(response);
        });
    }

    protected processPatchHide(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Hide all games which can be hidden for the current player
     */
    patchHideAll(): Promise<any> {
        let url_ = this.baseUrl + "/api/games/hide";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "PATCH",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPatchHideAll(response);
        });
    }

    protected processPatchHideAll(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, null);
    }
}

export class HistoryClient {
    private baseUrl: string | undefined = undefined;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;;
    }

    /**
     * Gets the specified turn including the actions and current state of the map
     */
    getTurn(gameId: number, turnId: number): Promise<HistoryTurn> {
        let url_ = this.baseUrl + "/api/games/{gameId}/history/{turnId}";
        if (gameId === undefined || gameId === null)
            throw new Error("The parameter 'gameId' must be defined.");
        url_ = url_.replace("{gameId}", encodeURIComponent("" + gameId)); 
        if (turnId === undefined || turnId === null)
            throw new Error("The parameter 'turnId' must be defined.");
        url_ = url_.replace("{turnId}", encodeURIComponent("" + turnId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetTurn(response);
        });
    }

    protected processGetTurn(response: Response): Promise<HistoryTurn> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: HistoryTurn | null = null;
                result200 = responseText === "" ? null : <HistoryTurn>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, null);
    }
}

export class LadderClient {
    private baseUrl: string | undefined = undefined;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;;
    }

    /**
     * Returns active ladders
     * @return List of ladders
     */
    getAll(): Promise<LadderSummary[]> {
        let url_ = this.baseUrl + "/api/ladder";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetAll(response);
        });
    }

    protected processGetAll(response: Response): Promise<LadderSummary[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: LadderSummary[] | null = null;
                result200 = responseText === "" ? null : <LadderSummary[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Gets ladder identified by given id
     * @ladderId Id of ladder
     */
    get(ladderId: string): Promise<Ladder> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}";
        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGet(response);
        });
    }

    protected processGet(response: Response): Promise<Ladder> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: Ladder | null = null;
                result200 = responseText === "" ? null : <Ladder>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Queue up for a new game in the given ladder
     * @ladderId Ladder id
     * @return Status
     */
    postJoin(ladderId: string): Promise<any> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}/queue";
        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = "";

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processPostJoin(response);
        });
    }

    protected processPostJoin(response: Response): Promise<any> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: any | null = null;
                result200 = responseText === "" ? null : <any>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Gets ladder standings
     * @ladderId Id of ladder
     * @start Items to skip before returning
     * @count Count of standings to return
     */
    getStandings(ladderId: string, start: number, count: number): Promise<LadderStanding[]> {
        let url_ = this.baseUrl + "/api/ladder/{ladderId}/standings?";
        if (ladderId === undefined || ladderId === null)
            throw new Error("The parameter 'ladderId' must be defined.");
        url_ = url_.replace("{ladderId}", encodeURIComponent("" + ladderId)); 
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent("" + start) + "&"; 
        if (count === null)
            throw new Error("The parameter 'count' cannot be null.");
        else if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetStandings(response);
        });
    }

    protected processGetStandings(response: Response): Promise<LadderStanding[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: LadderStanding[] | null = null;
                result200 = responseText === "" ? null : <LadderStanding[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, null);
    }
}

export class MapClient {
    private baseUrl: string | undefined = undefined;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;;
    }

    getAllSummary(): Promise<MapTemplateDescriptor[]> {
        let url_ = this.baseUrl + "/api/map";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetAllSummary(response);
        });
    }

    protected processGetAllSummary(response: Response): Promise<MapTemplateDescriptor[]> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: MapTemplateDescriptor[] | null = null;
                result200 = responseText === "" ? null : <MapTemplateDescriptor[]>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    /**
     * Get map template identified by name
     */
    getMapTemplate(name: string): Promise<MapTemplate> {
        let url_ = this.baseUrl + "/api/map/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Content-Type": "application/json; charset=UTF-8", 
                "Accept": "application/json; charset=UTF-8"
            }
        };

        return this.http.fetch(url_, options_).then((response: Response) => {
            return this.processGetMapTemplate(response);
        });
    }

    protected processGetMapTemplate(response: Response): Promise<MapTemplate> {
        return response.text().then((responseText) => {
            const status = response.status; 

            if (status === 200) {
                let result200: MapTemplate | null = null;
                result200 = responseText === "" ? null : <MapTemplate>JSON.parse(responseText, this.jsonParseReviver);
                return result200;
            } else if (status !== 200 && status !== 204) {
                this.throwException("An unexpected server error occurred.", status, responseText);
            }
            return null;
        });
    }

    protected throwException(message: string, status: number, response: string, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, null);
    }
}

export interface TournamentSummary {
    id: string | undefined;
    name: string | undefined;
    state: TournamentState | undefined;
    options?: GameOptions | null | undefined;
    numberOfTeams: number | undefined;
    numberOfGroupGames: number | undefined;
    numberOfKnockoutGames: number | undefined;
    numberOfFinalGames: number | undefined;
    startOfRegistration: Date | undefined;
    startOfTournament: Date | undefined;
    endOfTournament: Date | undefined;
    completion: number | undefined;
}

export interface Tournament extends TournamentSummary {
    teams?: TournamentTeam[] | null | undefined;
    groups?: TournamentGroup[] | null | undefined;
    pairings?: TournamentPairing[] | null | undefined;
    mapTemplates?: string[] | null | undefined;
    winner?: TournamentTeam | null | undefined;
    phase: number | undefined;
}

export interface TournamentTeamSummary {
    id: string | undefined;
    name?: string | null | undefined;
    groupOrder: number | undefined;
    state: TournamentTeamState | undefined;
}

export interface TournamentTeam extends TournamentTeamSummary {
    participants?: UserReference[] | null | undefined;
}

export interface UserReference {
    id?: string | null | undefined;
    name?: string | null | undefined;
}

export enum TournamentTeamState {
    Open = <any>"Open", 
    Active = <any>"Active", 
    InActive = <any>"InActive", 
}

export interface TournamentGroup {
    id: string | undefined;
    teams?: TournamentTeamSummary[] | null | undefined;
}

export interface TournamentPairing {
    teamA?: TournamentTeamSummary | null | undefined;
    teamB?: TournamentTeamSummary | null | undefined;
    teamAWon: number | undefined;
    teamBWon: number | undefined;
    numberOfGames: number | undefined;
    phase: number | undefined;
    order: number | undefined;
}

export enum TournamentState {
    Open = <any>"Open", 
    Groups = <any>"Groups", 
    Knockout = <any>"Knockout", 
    Closed = <any>"Closed", 
}

export interface GameOptions {
    numberOfPlayersPerTeam: number | undefined;
    numberOfTeams: number | undefined;
    minUnitsPerCountry: number | undefined;
    newUnitsPerTurn: number | undefined;
    attacksPerTurn: number | undefined;
    movesPerTurn: number | undefined;
    initialCountryUnits: number | undefined;
    mapDistribution: MapDistribution | undefined;
    timeoutInSeconds: number | undefined;
    maximumTimeoutsPerPlayer: number | undefined;
    maximumNumberOfCards: number | undefined;
    victoryConditions: VictoryConditionType[] | undefined;
    visibilityModifier: VisibilityModifierType[] | undefined;
}

export enum MapDistribution {
    Default = <any>"Default", 
    Malibu = <any>"Malibu", 
    TeamCluster = <any>"TeamCluster", 
}

export enum VictoryConditionType {
    Survival = <any>"Survival", 
    ControlContinent = <any>"ControlContinent", 
}

export enum VisibilityModifierType {
    None = <any>"None", 
    Fog = <any>"Fog", 
}

export interface PlaceUnitsOptions {
    countryIdentifier: string | undefined;
    numberOfUnits: number | undefined;
}

export interface GameActionResult {
    id: number | undefined;
    teams?: Team[] | null | undefined;
    state: GameState | undefined;
    playState: PlayState | undefined;
    countryUpdates?: Country[] | null | undefined;
    actionResult: ActionResult | undefined;
    unitsToPlace: number | undefined;
    attacksInCurrentTurn: number | undefined;
    movesInCurrentTurn: number | undefined;
    cards?: BonusCard[] | null | undefined;
    currentPlayer?: Player | null | undefined;
}

export interface Team {
    id: string | undefined;
    playOrder: number | undefined;
    players?: Player[] | null | undefined;
}

export interface PlayerSummary {
    id: string | undefined;
    userId?: string | null | undefined;
    name?: string | null | undefined;
    state: PlayerState | undefined;
    outcome: PlayerOutcome | undefined;
    teamId: string | undefined;
    playOrder: number | undefined;
    timeouts: number | undefined;
}

export interface Player extends PlayerSummary {
    cards?: BonusCard[] | null | undefined;
    placedInitialUnits: boolean | undefined;
    numberOfUnits: number | undefined;
    numberOfCountries: number | undefined;
}

export enum BonusCard {
    A = <any>"A", 
    B = <any>"B", 
    C = <any>"C", 
}

export enum PlayerState {
    None = <any>"None", 
    Active = <any>"Active", 
    InActive = <any>"InActive", 
}

export enum PlayerOutcome {
    None = <any>"None", 
    Won = <any>"Won", 
    Defeated = <any>"Defeated", 
    Surrendered = <any>"Surrendered", 
    Timeout = <any>"Timeout", 
}

export enum GameState {
    None = <any>"None", 
    Open = <any>"Open", 
    Active = <any>"Active", 
    Ended = <any>"Ended", 
}

export enum PlayState {
    None = <any>"None", 
    PlaceUnits = <any>"PlaceUnits", 
    Attack = <any>"Attack", 
    Move = <any>"Move", 
    Done = <any>"Done", 
}

export interface Country {
    identifier?: string | null | undefined;
    playerId: string | undefined;
    teamId: string | undefined;
    units: number | undefined;
}

export enum ActionResult {
    None = <any>"None", 
    Successful = <any>"Successful", 
    NotSuccessful = <any>"NotSuccessful", 
}

export interface AttackOptions {
    originCountryIdentifier: string | undefined;
    destinationCountryIdentifier: string | undefined;
    numberOfUnits: number | undefined;
}

export interface MoveOptions {
    originCountryIdentifier: string | undefined;
    destinationCountryIdentifier: string | undefined;
    numberOfUnits: number | undefined;
}

export interface Game {
    id: number | undefined;
    type: GameType | undefined;
    name?: string | null | undefined;
    mapTemplate?: string | null | undefined;
    teams?: Team[] | null | undefined;
    state: GameState | undefined;
    playState: PlayState | undefined;
    currentPlayer?: PlayerSummary | null | undefined;
    map?: Map | null | undefined;
    options?: GameOptions | null | undefined;
    lastModifiedAt: Date | undefined;
    timeoutSecondsLeft: number | undefined;
    turnCounter: number | undefined;
    unitsToPlace: number | undefined;
    attacksInCurrentTurn: number | undefined;
    movesInCurrentTurn: number | undefined;
}

export enum GameType {
    Fun = <any>"Fun", 
    Ranking = <any>"Ranking", 
    Tournament = <any>"Tournament", 
}

export interface Map {
    countries?: Country[] | null | undefined;
}

export interface NotificationSummary {
    numberOfGames: number | undefined;
    numberOfMessages: number | undefined;
}

export interface NewsItem {
    dateTime: Date | undefined;
    postedBy?: string | null | undefined;
    content?: NewsContent[] | null | undefined;
}

export interface NewsContent {
    language?: string | null | undefined;
    title?: string | null | undefined;
    text?: string | null | undefined;
}

export enum MessageFolder {
    None = <any>"None", 
    Inbox = <any>"Inbox", 
    Sent = <any>"Sent", 
}

export interface SendMessage {
    to: UserReference | undefined;
    subject?: string | null | undefined;
    text?: string | null | undefined;
}

export interface Message extends SendMessage {
    id: string | undefined;
    from?: UserReference | null | undefined;
    folder: MessageFolder | undefined;
    sentAt: Date | undefined;
    isRead: boolean | undefined;
}

export interface FolderInformation {
    folder: MessageFolder | undefined;
    count: number | undefined;
    unreadCount: number | undefined;
}

export interface LoginResponseModel {
    access_token?: string | null | undefined;
    refresh_token?: string | null | undefined;
}

export interface UserInfo {
    userId?: string | null | undefined;
    userName?: string | null | undefined;
    hasRegistered: boolean | undefined;
    loginProvider?: string | null | undefined;
    language?: string | null | undefined;
    roles?: string[] | null | undefined;
}

export interface ManageInfoViewModel {
    localLoginProvider?: string | null | undefined;
    userName?: string | null | undefined;
    logins?: UserLoginInfoViewModel[] | null | undefined;
    externalLoginProviders?: ExternalLoginViewModel[] | null | undefined;
}

export interface UserLoginInfoViewModel {
    loginProvider?: string | null | undefined;
    providerKey?: string | null | undefined;
}

export interface ExternalLoginViewModel {
    name?: string | null | undefined;
    url?: string | null | undefined;
    state?: string | null | undefined;
}

export interface ChangePasswordBindingModel {
    oldPassword: string | undefined;
    newPassword: string | undefined;
    confirmPassword?: string | null | undefined;
}

export interface SetPasswordBindingModel {
    newPassword: string | undefined;
    confirmPassword?: string | null | undefined;
}

export interface RemoveLoginBindingModel {
    loginProvider: string | undefined;
    providerKey: string | undefined;
}

export interface RegisterBindingModel {
    userName: string | undefined;
    password: string | undefined;
    confirmPassword?: string | null | undefined;
    email: string | undefined;
    language: string | undefined;
    callbackUrl: string | undefined;
}

export interface ErrorResponse {
    error?: string | null | undefined;
    error_Description?: string | null | undefined;
    parameter_Errors?: { [key: string] : string[]; } | null | undefined;
}

export interface ResendConfirmationModel {
    callbackUrl: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    language: string | undefined;
}

export interface ConfirmationModel {
    userId: string | undefined;
    code: string | undefined;
}

export interface ForgotPasswordViewModel {
    callbackUrl: string | undefined;
    userName: string | undefined;
    email: string | undefined;
    language: string | undefined;
}

export interface ResetPasswordViewModel {
    userId: string | undefined;
    password: string | undefined;
    confirmPassword?: string | null | undefined;
    code: string | undefined;
}

export interface RegisterExternalBindingModel {
    userName: string | undefined;
    email: string | undefined;
}

export interface GameSummary {
    id: number | undefined;
    type: GameType | undefined;
    name?: string | null | undefined;
    ladderId?: string | null | undefined;
    ladderName?: string | null | undefined;
    options?: GameOptions | null | undefined;
    createdByUserId?: string | null | undefined;
    createdByName?: string | null | undefined;
    startedAt?: Date | null | undefined;
    lastActionAt: Date | undefined;
    timeoutSecondsLeft: number | undefined;
    mapTemplate?: string | null | undefined;
    state: GameState | undefined;
    currentPlayer?: PlayerSummary | null | undefined;
    teams?: TeamSummary[] | null | undefined;
}

export interface TeamSummary {
    id: string | undefined;
    playOrder: number | undefined;
    players?: PlayerSummary[] | null | undefined;
}

export interface GameCreationOptions extends GameOptions {
    name: string | undefined;
    addBot: boolean | undefined;
    mapTemplate: string | undefined;
}

export interface GameChatMessage {
    id: number | undefined;
    gameId: number | undefined;
    user?: UserReference | null | undefined;
    teamId: string | undefined;
    dateTime: Date | undefined;
    text?: string | null | undefined;
}

export interface HistoryTurn {
    gameId: number | undefined;
    turnId: number | undefined;
    actions?: HistoryEntry[] | null | undefined;
    game?: Game | null | undefined;
}

export interface HistoryEntry {
    id: number | undefined;
    turnNo: number | undefined;
    dateTime: Date | undefined;
    actorId: string | undefined;
    otherPlayerId?: string | null | undefined;
    action: HistoryAction | undefined;
    originIdentifier?: string | null | undefined;
    destinationIdentifier?: string | null | undefined;
    units?: number | null | undefined;
    unitsLost?: number | null | undefined;
    unitsLostOther?: number | null | undefined;
    result?: boolean | null | undefined;
}

export enum HistoryAction {
    None = <any>"None", 
    StartGame = <any>"StartGame", 
    EndGame = <any>"EndGame", 
    PlaceUnits = <any>"PlaceUnits", 
    Attack = <any>"Attack", 
    Move = <any>"Move", 
    ExchangeCards = <any>"ExchangeCards", 
    PlayerLost = <any>"PlayerLost", 
    PlayerWon = <any>"PlayerWon", 
    PlayerTimeout = <any>"PlayerTimeout", 
    OwnerChange = <any>"OwnerChange", 
    EndTurn = <any>"EndTurn", 
}

export interface LadderSummary {
    id: string | undefined;
    name?: string | null | undefined;
    options?: GameOptions | null | undefined;
    standing?: LadderStanding | null | undefined;
    isQueued: boolean | undefined;
    queueCount: number | undefined;
    mapTemplates: string[] | undefined;
}

export interface LadderStanding {
    userId?: string | null | undefined;
    userName?: string | null | undefined;
    position: number | undefined;
    gamesPlayed: number | undefined;
    gamesWon: number | undefined;
    gamesLost: number | undefined;
    rating: number | undefined;
    lastGame: Date | undefined;
}

export interface Ladder extends LadderSummary {
    standings?: LadderStanding[] | null | undefined;
    isActive: boolean | undefined;
}

export interface MapTemplateDescriptor {
    name?: string | null | undefined;
}

export interface MapTemplate {
    name?: string | null | undefined;
    image?: string | null | undefined;
    countries?: CountryTemplate[] | null | undefined;
    connections?: Connection[] | null | undefined;
    continents?: Continent[] | null | undefined;
}

export interface CountryTemplate {
    identifier?: string | null | undefined;
    name?: string | null | undefined;
    x: number | undefined;
    y: number | undefined;
}

export interface Connection {
    origin?: string | null | undefined;
    destination?: string | null | undefined;
}

export interface Continent {
    id: number | undefined;
    name?: string | null | undefined;
    bonus: number | undefined;
    countries?: string[] | null | undefined;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    result: any; 

    constructor(message: string, status: number, response: string, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.result = result;
    }
}